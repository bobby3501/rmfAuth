"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var RestClient = require('rest');
var de_connection_1 = require("./de.connection");
var DATAENGINE_DEFAULT_PORT = 4300;
var HTTPS_DEFAULT_PORT = 443;
var HTTP_DEFAULT_PORT = 80;
var HTTP_RESPONSE_OK = 200;
var HTTP_RESPONSE_NOT_FOUND = 404;
var HTTP_RESPONSE_CREATED = 201;
var HTTP_RESPONSE_NOT_MODIFIED = 304;
var MAX_CONCURRENT = 50;
var TimeoutError = (function (_super) {
    __extends(TimeoutError, _super);
    function TimeoutError(message, progressTimeout) {
        var _this = _super.call(this, message) || this;
        Error.captureStackTrace(_this, _this.constructor);
        _this.progressTimeout = progressTimeout;
        return _this;
    }
    return TimeoutError;
}(Error));
exports.TimeoutError = TimeoutError;
var AlreadyExistsError = (function (_super) {
    __extends(AlreadyExistsError, _super);
    function AlreadyExistsError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = 'AlreadyExistsError';
        Error.captureStackTrace(_this, _this.constructor);
        return _this;
    }
    return AlreadyExistsError;
}(Error));
exports.AlreadyExistsError = AlreadyExistsError;
function generateUUID() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }
    return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
        s4() + '-' + s4() + s4() + s4();
}
exports.generateUUID = generateUUID;
var DataEngineSettings = (function () {
    function DataEngineSettings() {
        this.bucket = null;
        this.host = null;
        this.port = null;
        this.path = '';
        this.apiKey = null;
        this.secure = false;
        this.enablePing = false;
        this.pingInterval = 5000;
        this.clientId = null;
    }
    return DataEngineSettings;
}());
exports.DataEngineSettings = DataEngineSettings;
;
var RequestOptions = (function () {
    function RequestOptions(options) {
        this.bucket = null;
        this.data = null;
        this.failIfExists = false;
        this.expire = null;
        this.async = true;
        this.forceHttp = false;
        this.keysOnly = false;
        this.filter = null;
        if (options) {
            this.bucket = options.bucket;
            this.data = options.data;
            this.failIfExists = options.failIfExists;
            this.expire = options.expire;
            this.async = options.async;
            this.forceHttp = options.forceHttp;
            this.keysOnly = options.keysOnly;
            this.filter = options.filter;
        }
    }
    return RequestOptions;
}());
exports.RequestOptions = RequestOptions;
var RequestOptionsInternal = (function (_super) {
    __extends(RequestOptionsInternal, _super);
    function RequestOptionsInternal() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.url = null;
        _this.method = null;
        _this.key = null;
        _this.forceHttp = false;
        _this.keysOnly = false;
        _this.filter = null;
        return _this;
    }
    return RequestOptionsInternal;
}(RequestOptions));
exports.RequestOptionsInternal = RequestOptionsInternal;
var DataEngine = (function () {
    function DataEngine(settings) {
        this.restClient = null;
        this.connection = null;
        this.settings = null;
        this.pendingRequests = 0;
        this.internalizeRequestOptions = function (key, options) {
            var bucket = options.bucket || this.settings.bucket;
            if (options.async == null)
                options.async = true;
            var opt = new RequestOptionsInternal(null);
            if (options.keysOnly !== undefined)
                opt.keysOnly = options.keysOnly;
            if (options.filter !== undefined)
                opt.filter = options.filter;
            opt.url = this.getUrl(key, bucket, opt.keysOnly, opt.filter);
            opt.bucket = bucket;
            opt.key = key;
            opt.async = options.async;
            opt.failIfExists = options.failIfExists;
            opt.forceHttp = options.forceHttp;
            opt.expire = options.expire;
            return opt;
        };
        this.checkOptions = function (options) {
            if (options instanceof RequestOptions === false) {
                options = new RequestOptions(options);
            }
            return options;
        };
        this.read = function (key, options) {
            return __awaiter(this, void 0, void 0, function () {
                var opt;
                return __generator(this, function (_a) {
                    opt = this.internalizeRequestOptions(key, this.checkOptions(options));
                    opt.method = 'GET';
                    return [2, this.request(opt)];
                });
            });
        };
        this.list = function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var opt;
                return __generator(this, function (_a) {
                    if (options.keysOnly === undefined)
                        options.keysOnly = true;
                    opt = this.internalizeRequestOptions('', this.checkOptions(options));
                    opt.method = 'GET';
                    return [2, this.request(opt)];
                });
            });
        };
        this.write = function (key, value, options) {
            return __awaiter(this, void 0, void 0, function () {
                var opt;
                return __generator(this, function (_a) {
                    opt = this.internalizeRequestOptions(key, this.checkOptions(options));
                    opt.method = opt.key ? 'PUT' : 'POST';
                    opt.data = value;
                    return [2, this.request(opt)];
                });
            });
        };
        this.patch = function (key, patch, options) {
            return __awaiter(this, void 0, void 0, function () {
                var opt;
                return __generator(this, function (_a) {
                    opt = this.internalizeRequestOptions(key, this.checkOptions(options));
                    opt.method = 'PATCH';
                    opt.data = patch;
                    return [2, this.request(opt)];
                });
            });
        };
        this.remove = function (key, options) {
            return __awaiter(this, void 0, void 0, function () {
                var opt;
                return __generator(this, function (_a) {
                    opt = this.internalizeRequestOptions(key, this.checkOptions(options));
                    opt.method = 'DELETE';
                    return [2, this.request(opt)];
                });
            });
        };
        this.getUrl = function (key, bucket, keysOnly, filter) {
            if (!key)
                key = '';
            var suffix = 'd=' + new Date().getTime();
            suffix = ((key.indexOf('?') > -1) ? '&' : '?') + suffix;
            if (keysOnly)
                suffix = suffix + '&keysOnly=true';
            if ((filter != null) && (filter !== ''))
                suffix = suffix + '&filter=' + filter;
            var protocol = this.settings.secure ? 'https://' : 'http://';
            var url = protocol + this.settings.host + ':' + this.settings.port + this.settings.path + '_data/' + bucket + '/' + key + suffix;
            return url;
        };
        this.request = function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                var _resolve, _reject, promise, queueItem;
                return __generator(this, function (_a) {
                    promise = new Promise(function (resolve, reject) {
                        _resolve = resolve;
                        _reject = reject;
                    });
                    if (options.async === undefined)
                        options.async = true;
                    queueItem = { resolve: _resolve, reject: _reject, options: options };
                    setImmediate(function () {
                        _this.requestQueue.unshift(queueItem);
                        _this.processRequestQueue();
                    });
                    return [2, promise];
                });
            });
        };
        this.close = function () {
            this.connection.close();
        };
        var self = this;
        this.restClient = RestClient;
        if (settings == null)
            settings = new DataEngineSettings();
        settings.host = settings.host || '127.0.0.1';
        settings.port = settings.port || DATAENGINE_DEFAULT_PORT;
        if (typeof settings.path !== 'string')
            settings.path = '';
        if ((settings.path !== '') && (settings.path.charAt(0) !== '/')) {
            settings.path = '/' + settings.path;
        }
        if (settings.path.charAt(settings.path.length - 1) !== '/') {
            settings.path = settings.path + '/';
        }
        this.settings = settings;
        this.connection = new de_connection_1.PersistentConnection(settings);
        this.requestQueue = [];
    }
    DataEngine.prototype.requestHttp = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var method, request;
            return __generator(this, function (_a) {
                method = options.method || 'GET';
                request = {
                    method: method,
                    path: options.url,
                    headers: {},
                    entity: {}
                };
                if (this.settings.apiKey) {
                    request.headers['API-key'] = this.settings.apiKey;
                }
                if ((method == 'PUT') || (method == 'POST') || (method == 'PATCH')) {
                    request.entity = JSON.stringify(options.data);
                    request.headers['Content-Type'] = 'application/json';
                    if (options.failIfExists) {
                        request.headers['failIfExists'] = options.failIfExists;
                    }
                    ;
                    if (options.expire) {
                        request.headers['expire'] = options.expire;
                    }
                }
                return [2, this.restClient(request)
                        .then(function (response) {
                        if ((method === 'GET') && ([HTTP_RESPONSE_OK, HTTP_RESPONSE_NOT_MODIFIED].indexOf(response.status.code) > -1)) {
                            return JSON.parse(response.entity);
                        }
                        else if ((['POST', 'PUT'].indexOf(method) > -1) && ([HTTP_RESPONSE_OK, HTTP_RESPONSE_CREATED].indexOf(response.status.code) > -1)) {
                            var key = options.key;
                            if (response.status.code === HTTP_RESPONSE_CREATED) {
                                key = response.headers['location'];
                            }
                            return key;
                        }
                        else if ((method === 'DELETE') && ([HTTP_RESPONSE_OK, HTTP_RESPONSE_NOT_FOUND].indexOf(response.status.code) > -1)) {
                            return;
                        }
                        else if (response.status.code == HTTP_RESPONSE_OK) {
                            return;
                        }
                        else {
                            throw new Error(response.status.code);
                        }
                    })];
            });
        });
    };
    DataEngine.prototype.processRequestQueue = function () {
        var _this = this;
        if ((this.pendingRequests >= MAX_CONCURRENT) || (this.requestQueue.length === 0)) {
            return;
        }
        var item = this.requestQueue.pop();
        this.pendingRequests++;
        var promise;
        if ((this.connection) && (item.options.async) && (this.connection.connected) && (!item.options.forceHttp)) {
            promise = this.connection.request(item.options);
        }
        else {
            promise = this.requestHttp(item.options);
        }
        promise
            .then(function (obj) {
            _this.pendingRequests--;
            item.resolve(obj);
            setImmediate(_this.processRequestQueue.bind(_this));
        })
            .catch(function (err) {
            _this.pendingRequests--;
            item.reject(err);
            setImmediate(_this.processRequestQueue.bind(_this));
        });
    };
    return DataEngine;
}());
exports.DataEngine = DataEngine;
